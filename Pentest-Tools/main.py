import sys
from utils.craw_init import execute_crawl
from utils.crawl_parser import extract_data_from_file
from requests import Request, Session
import asyncio
from concurrent.futures import ThreadPoolExecutor
from utils.interactsh_client import InteractshSession, public_interactsh_servers
from random import choice
from requestHelper import RequestHelper
import socket
import json
from urllib.parse import urlparse
from requests.exceptions import RequestException
from publicsuffix2 import get_public_suffix
# from termcolor import colored, cprint


class Driver:

    def __init__(self, domain, scan_option):
        self.domain = domain
        self.scan_option = scan_option

    async def make_requests_async(self, forms_array,
                                  oob_server, loop):
        with ThreadPoolExecutor(max_workers=len(forms_array)) as executor:
            with Session() as session:
                # Set any session parameters here before calling `fetch`
                loop = asyncio.get_event_loop()
                tasks = [
                    loop.run_in_executor(
                        executor,
                        self.fetch,
                        *(session, form, oob_server
                          )  # Allows us to pass in multiple arguments to `fetch`
                    ) for form in forms_array
                ]
            
                for response in await asyncio.gather(*tasks):
                    pass

    def fetch(self, session, form_data, oob_server):
        requestObject = RequestHelper(form_data, self.scan_option, oob_server)
        for body in requestObject.params:
            req = Request(method=requestObject.method,
                          url="https://"+requestObject.url,
                          data=body if requestObject.headers["Content-Type"] != "application/json" else json.dumps(
                              body),
                          headers=requestObject.headers)
            req = req.prepare()
            try:
                session.send(req)
            except (RequestException, ConnectionError):
                continue

    def execute_report(self):
        crawl_status = execute_crawl(self.domain)
        if crawl_status != 1:
            print(
                "[*] Something went wrong during crawling, aborting the execution...")
        else:
            print("[*] Crawling done...")
            forms_data = extract_data_from_file(
                "VulnTester/forms.json")
            if not forms_data or len(forms_data) == 0:
                
                print("[*] No HTML forms were found after parsing, aborting ...")
            else:
                print("[*] Parsing crawled data done...")
                server_instance = InteractshSession.new(
                    choice(public_interactsh_servers))
                if not server_instance:
                    print("[*] Out of band server could not be started, aborting...")
                hostname = server_instance.generate_hostname()
                print("[*] Starting server for out of band done...")
                loop = asyncio.get_event_loop()
                future = asyncio.ensure_future(
                    self.make_requests_async(forms_data, '8u3pta67cwoizpdslb6d62eac1is6lua.oastify.com', loop))
                loop.run_until_complete(future)
                self.check_if_vulnerable(server_instance, loop)
                print(
                    "[*] SERVER WAS NOT FOUND VULNERABLE TO {scan_type}".format(scan_type=self.scan_option))
                # server_status  = check_out_of_bound_data()
                # print("[*] Starting server for out of band done...")

    def shutdown(self, loop):
        loop.stop()
        pending = asyncio.all_tasks()
        # Run loop until tasks done:
        loop.run_until_complete(asyncio.gather(*pending))
        print("Shutdown complete of all processes ...")

    def check_if_vulnerable(self, server_instance, loop):
        while True:
            if loop.is_running():
                parsed_domain = urlparse('https://'+self.domain).hostname
                target_ip = socket.gethostbyname(parsed_domain if parsed_domain else self.domain.strip('/'))
                for interaction in server_instance.poll():
                    found=0
                    if interaction.q_type in [
                       'A', 'AAAA'
                    ]:
                        found += 1
                    if interaction.remote_address in [target_ip]:
                        found += 1
                    if found == 2:
                        self.shutdown(loop)
                        print("[!!!] TARGET FOUND VULNERABLE TO {scan_type}".format(
                            scan_type=self.scan_option))
                        return 1
                return 0
            else: 
                parsed_domain = urlparse('https://'+self.domain).hostname
                target_ip = socket.gethostbyname(parsed_domain if parsed_domain else self.domain.strip('/'))
                for interaction in server_instance.poll():
                    found=0
                    if interaction.q_type in [
                        'A', 'AAAA'
                    ]:
                        found += 1
                    if interaction.remote_address in [target_ip]:
                        found += 1
                    if found == 2:
                        self.shutdown(loop)
                        print("[!!!] TARGET FOUND VULNERABLE TO {scan_type}".format(
                            scan_type=self.scan_option))
                        return 1
                return 0
            


if __name__ == "__main__":
    driver = Driver('0aa9000504831808c0984016001f002f.web-security-academy.net', 'ssti')
    driver.execute_report()

